
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>11.4 套接字接口 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.7.1">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="11.5-web-servers.html" />
    
    
    <link rel="prev" href="11.3-the-global-ip-internet.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    本电子书信息
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">出版信息</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../../publish-info/publisher-words.html">
            
                <a href="../../publish-info/publisher-words.html">
            
                    
                    出版者的话
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../../publish-info/chinese-preface-1.html">
            
                <a href="../../publish-info/chinese-preface-1.html">
            
                    
                    中文版序一
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../../publish-info/chinese-preface-2.html">
            
                <a href="../../publish-info/chinese-preface-2.html">
            
                    
                    中文版序二
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../../publish-info/translators-preface.html">
            
                <a href="../../publish-info/translators-preface.html">
            
                    
                    译者序
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../../publish-info/preface.html">
            
                <a href="../../publish-info/preface.html">
            
                    
                    前言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="../../publish-info/about-authors.html">
            
                <a href="../../publish-info/about-authors.html">
            
                    
                    关于作者
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../../ch01-a-tour-of-computer-systems/">
            
                <a href="../../ch01-a-tour-of-computer-systems/">
            
                    
                    第 1 章：计算机系统漫游
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="../../ch01-a-tour-of-computer-systems/1.1.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.1.html">
            
                    
                    1.1 信息就是位 + 上下文
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="../../ch01-a-tour-of-computer-systems/1.2.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.2.html">
            
                    
                    1.2 程序被其他程序翻译成不同的格式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="../../ch01-a-tour-of-computer-systems/1.3.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.3.html">
            
                    
                    1.3 了解编译系统如何工作是大有益处的
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="../../ch01-a-tour-of-computer-systems/1.4.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.4.html">
            
                    
                    1.4 处理器读并解释储存在内存中的指令
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="../../ch01-a-tour-of-computer-systems/1.5.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.5.html">
            
                    
                    1.5 高速缓存至关重要
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.6" data-path="../../ch01-a-tour-of-computer-systems/1.6.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.6.html">
            
                    
                    1.6 存储设备形成层次结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.7" data-path="../../ch01-a-tour-of-computer-systems/1.7.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.7.html">
            
                    
                    1.7 操作系统管理硬件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.8" data-path="../../ch01-a-tour-of-computer-systems/1.8.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.8.html">
            
                    
                    1.8 系统之间利用网络通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.9" data-path="../../ch01-a-tour-of-computer-systems/1.9.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.9.html">
            
                    
                    1.9 重要主题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.10" data-path="../../ch01-a-tour-of-computer-systems/1.10-xiao-jie.html">
            
                <a href="../../ch01-a-tour-of-computer-systems/1.10-xiao-jie.html">
            
                    
                    1.10 小结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">第一部分：程序结构和执行</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../../part1/ch02-representing-and-manipulating-information/">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/">
            
                    
                    第 2 章：信息的表示和处理
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../../part1/ch02-representing-and-manipulating-information/2.1-xin-xi-cun-chu.html">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/2.1-xin-xi-cun-chu.html">
            
                    
                    2.1 信息存储
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../../part1/ch02-representing-and-manipulating-information/2.2-zheng-shu-biao-shi.html">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/2.2-zheng-shu-biao-shi.html">
            
                    
                    2.2 整数表示
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="../../part1/ch02-representing-and-manipulating-information/2.3-zheng-shu-yun-suan.html">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/2.3-zheng-shu-yun-suan.html">
            
                    
                    2.3 整数运算
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4" data-path="../../part1/ch02-representing-and-manipulating-information/2.4-fu-dian-shu.html">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/2.4-fu-dian-shu.html">
            
                    
                    2.4 浮点数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5" data-path="../../part1/ch02-representing-and-manipulating-information/2.5-xiao-jie.html">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/2.5-xiao-jie.html">
            
                    
                    2.5 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6" data-path="../../part1/ch02-representing-and-manipulating-information/jia-ting-zuo-ye.html">
            
                <a href="../../part1/ch02-representing-and-manipulating-information/jia-ting-zuo-ye.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../../part1/ch03-machine-level-representing-of-programs/">
            
                <a href="../../part1/ch03-machine-level-representing-of-programs/">
            
                    
                    第 3 章：程序的机器级表示
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.2.1" data-path="../../part1/ch03-machine-level-representing-of-programs/3.1-a-historial-perspective.html">
            
                <a href="../../part1/ch03-machine-level-representing-of-programs/3.1-a-historial-perspective.html">
            
                    
                    3.1 历史观点
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.2" data-path="../../part1/ch03-machine-level-representing-of-programs/3.2-program-encodings.html">
            
                <a href="../../part1/ch03-machine-level-representing-of-programs/3.2-program-encodings.html">
            
                    
                    3.2 程序编码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.3" data-path="../../part1/ch03-machine-level-representing-of-programs/3.3-data-formats.html">
            
                <a href="../../part1/ch03-machine-level-representing-of-programs/3.3-data-formats.html">
            
                    
                    3.3 数据格式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.4" data-path="../../part1/ch03-machine-level-representing-of-programs/3.4-accessing-information.html">
            
                <a href="../../part1/ch03-machine-level-representing-of-programs/3.4-accessing-information.html">
            
                    
                    3.4 访问信息
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="../../part1/ch04-processor-architecture.html">
            
                <a href="../../part1/ch04-processor-architecture.html">
            
                    
                    第 4 章：处理器体系结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="../../part1/ch05-optimizing-program-performance.html">
            
                <a href="../../part1/ch05-optimizing-program-performance.html">
            
                    
                    第 5 章：优化程序性能
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="../../part1/ch06-the-memory-hierarchy.html">
            
                <a href="../../part1/ch06-the-memory-hierarchy.html">
            
                    
                    第 6 章：存储器层次结构
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第二部分：在系统上运行程序</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../../part2/ch07-linking/">
            
                <a href="../../part2/ch07-linking/">
            
                    
                    第 7 章：链接
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" data-path="../../part2/ch07-linking/7.1-compiler-drviers.html">
            
                <a href="../../part2/ch07-linking/7.1-compiler-drviers.html">
            
                    
                    7.1 编译器驱动程序
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.2" data-path="../../part2/ch07-linking/7.2-static-linking.html">
            
                <a href="../../part2/ch07-linking/7.2-static-linking.html">
            
                    
                    7.2 静态链接
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.3" data-path="../../part2/ch07-linking/7.3-object-files.html">
            
                <a href="../../part2/ch07-linking/7.3-object-files.html">
            
                    
                    7.3 目标文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.4" data-path="../../part2/ch07-linking/7.4-relocatable-object-files.html">
            
                <a href="../../part2/ch07-linking/7.4-relocatable-object-files.html">
            
                    
                    7.4 可重定位目标文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.5" data-path="../../part2/ch07-linking/7.5-symbols-and-symbol-tables.html">
            
                <a href="../../part2/ch07-linking/7.5-symbols-and-symbol-tables.html">
            
                    
                    7.5 符号和符号表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.6" data-path="../../part2/ch07-linking/7.6-symbol-resolution.html">
            
                <a href="../../part2/ch07-linking/7.6-symbol-resolution.html">
            
                    
                    7.6 符号解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.7" data-path="../../part2/ch07-linking/7.7-relocation.html">
            
                <a href="../../part2/ch07-linking/7.7-relocation.html">
            
                    
                    7.7 重定位
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.8" data-path="../../part2/ch07-linking/7.8-executable-object-files.html">
            
                <a href="../../part2/ch07-linking/7.8-executable-object-files.html">
            
                    
                    7.8 可执行目标文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.9" data-path="../../part2/ch07-linking/7.9-loading-executable-object-files.html">
            
                <a href="../../part2/ch07-linking/7.9-loading-executable-object-files.html">
            
                    
                    7.9 加载可执行目标文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.10" data-path="../../part2/ch07-linking/7.10-dynamic-linking-with-shared-libraries.html">
            
                <a href="../../part2/ch07-linking/7.10-dynamic-linking-with-shared-libraries.html">
            
                    
                    7.10 动态链接共享库
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.11" data-path="../../part2/ch07-linking/7.11-loading-and-linking-shared-libraries-from-applications.html">
            
                <a href="../../part2/ch07-linking/7.11-loading-and-linking-shared-libraries-from-applications.html">
            
                    
                    7.11 从应用程序中加载和链接共享库
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.12" data-path="../../part2/ch07-linking/7.12-position-independent-code.html">
            
                <a href="../../part2/ch07-linking/7.12-position-independent-code.html">
            
                    
                    7.12 位置无关代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.13" data-path="../../part2/ch07-linking/7.13-library-interpositioning.html">
            
                <a href="../../part2/ch07-linking/7.13-library-interpositioning.html">
            
                    
                    7.13 库打桩机制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.14" data-path="../../part2/ch07-linking/7.14-tools-for-manipulating-object-files.html">
            
                <a href="../../part2/ch07-linking/7.14-tools-for-manipulating-object-files.html">
            
                    
                    7.14 处理目标文件的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.15" data-path="../../part2/ch07-linking/7.15-summary.html">
            
                <a href="../../part2/ch07-linking/7.15-summary.html">
            
                    
                    7.15 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.16" data-path="../../part2/ch07-linking/homework.html">
            
                <a href="../../part2/ch07-linking/homework.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="../../part2/ch08-exceptional-control-flow/">
            
                <a href="../../part2/ch08-exceptional-control-flow/">
            
                    
                    第 8 章：异常控制流
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.2.1" data-path="../../part2/ch08-exceptional-control-flow/8.1-exceptions.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.1-exceptions.html">
            
                    
                    8.1 异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.2" data-path="../../part2/ch08-exceptional-control-flow/8.2-processes.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.2-processes.html">
            
                    
                    8.2 进程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.3" data-path="../../part2/ch08-exceptional-control-flow/8.3-system-call-error-handling.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.3-system-call-error-handling.html">
            
                    
                    8.3 系统调用错误处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.4" data-path="../../part2/ch08-exceptional-control-flow/8.4-process-control.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.4-process-control.html">
            
                    
                    8.4 进程控制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.5" data-path="../../part2/ch08-exceptional-control-flow/8.5-signals.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.5-signals.html">
            
                    
                    8.5 信号
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.6" data-path="../../part2/ch08-exceptional-control-flow/8.6-nonlocal-jumps.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.6-nonlocal-jumps.html">
            
                    
                    8.6 非本地跳转
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.7" data-path="../../part2/ch08-exceptional-control-flow/8.7-tools-for-manipulating-processes.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.7-tools-for-manipulating-processes.html">
            
                    
                    8.7 操作进程的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.8" data-path="../../part2/ch08-exceptional-control-flow/8.8-summary.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/8.8-summary.html">
            
                    
                    8.8 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2.9" data-path="../../part2/ch08-exceptional-control-flow/homework.html">
            
                <a href="../../part2/ch08-exceptional-control-flow/homework.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="5.3" data-path="../../part2/ch09-virtual-memory/">
            
                <a href="../../part2/ch09-virtual-memory/">
            
                    
                    第 9 章：虚拟内存
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.3.1" data-path="../../part2/ch09-virtual-memory/9.1-physical-and-virtual-addressing.html">
            
                <a href="../../part2/ch09-virtual-memory/9.1-physical-and-virtual-addressing.html">
            
                    
                    9.1 物理和虚拟寻址
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.2" data-path="../../part2/ch09-virtual-memory/9.2-address-spaces.html">
            
                <a href="../../part2/ch09-virtual-memory/9.2-address-spaces.html">
            
                    
                    9.2 地址空间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.3" data-path="../../part2/ch09-virtual-memory/9.3-vm-as-a-tool-for-caching.html">
            
                <a href="../../part2/ch09-virtual-memory/9.3-vm-as-a-tool-for-caching.html">
            
                    
                    9.3 虚拟内存作为缓存的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.4" data-path="../../part2/ch09-virtual-memory/9.4-vm-as-a-tool-for-memory-management.html">
            
                <a href="../../part2/ch09-virtual-memory/9.4-vm-as-a-tool-for-memory-management.html">
            
                    
                    9.4 虚拟内存作为内存管理的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.5" data-path="../../part2/ch09-virtual-memory/9.5-vm-as-a-tool-for-memory-protection.html">
            
                <a href="../../part2/ch09-virtual-memory/9.5-vm-as-a-tool-for-memory-protection.html">
            
                    
                    9.5 虚拟内存作为内存保护的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.6" data-path="../../part2/ch09-virtual-memory/9.6-address-translation.html">
            
                <a href="../../part2/ch09-virtual-memory/9.6-address-translation.html">
            
                    
                    9.6 地址翻译
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.7" data-path="../../part2/ch09-virtual-memory/9.7-case-study-the-intel-core-i7-linux-memory-system.html">
            
                <a href="../../part2/ch09-virtual-memory/9.7-case-study-the-intel-core-i7-linux-memory-system.html">
            
                    
                    9.7 案例研究：Intel Core i7 / Linux 内存系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.8" data-path="../../part2/ch09-virtual-memory/9.8-memory-mapping.html">
            
                <a href="../../part2/ch09-virtual-memory/9.8-memory-mapping.html">
            
                    
                    9.8 内存映射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.9" data-path="../../part2/ch09-virtual-memory/9.9-dynamic-memory-allocation.html">
            
                <a href="../../part2/ch09-virtual-memory/9.9-dynamic-memory-allocation.html">
            
                    
                    9.9 动态内存分配
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.10" data-path="../../part2/ch09-virtual-memory/9.10-garbage-collection.html">
            
                <a href="../../part2/ch09-virtual-memory/9.10-garbage-collection.html">
            
                    
                    9.10 垃圾收集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.11" data-path="../../part2/ch09-virtual-memory/9.11-common-memoory-related-bugs-in-c-programs.html">
            
                <a href="../../part2/ch09-virtual-memory/9.11-common-memoory-related-bugs-in-c-programs.html">
            
                    
                    9.11 C 程序中常见的与内存有关的错误
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.12" data-path="../../part2/ch09-virtual-memory/9.12-summary.html">
            
                <a href="../../part2/ch09-virtual-memory/9.12-summary.html">
            
                    
                    9.12 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3.13" data-path="../../part2/ch09-virtual-memory/homework.html">
            
                <a href="../../part2/ch09-virtual-memory/homework.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">第三部分：程序间的交互和通信</li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../ch10-system-level-io/">
            
                <a href="../ch10-system-level-io/">
            
                    
                    第 10 章：系统级 I/O
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" data-path="../ch10-system-level-io/10.1-unix-io.html">
            
                <a href="../ch10-system-level-io/10.1-unix-io.html">
            
                    
                    10.1 Unix I/O
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.2" data-path="../ch10-system-level-io/10.2-files.html">
            
                <a href="../ch10-system-level-io/10.2-files.html">
            
                    
                    10.2 文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.3" data-path="../ch10-system-level-io/10.3-opening-and-closing-files.html">
            
                <a href="../ch10-system-level-io/10.3-opening-and-closing-files.html">
            
                    
                    10.3 打开和关闭文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.4" data-path="../ch10-system-level-io/10.4-reading-and-writing-files.html">
            
                <a href="../ch10-system-level-io/10.4-reading-and-writing-files.html">
            
                    
                    10.4 读和写文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.5" data-path="../ch10-system-level-io/10.5-robust-reading-and-writing-with-the-rio-package.html">
            
                <a href="../ch10-system-level-io/10.5-robust-reading-and-writing-with-the-rio-package.html">
            
                    
                    10.5 用 RIO 包健壮地读写
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.6" data-path="../ch10-system-level-io/10.6-reading-file-metadata.html">
            
                <a href="../ch10-system-level-io/10.6-reading-file-metadata.html">
            
                    
                    10.6 读取文件元数据
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.7" data-path="../ch10-system-level-io/10.7-reading-directory-contents.html">
            
                <a href="../ch10-system-level-io/10.7-reading-directory-contents.html">
            
                    
                    10.7 读取目录内容
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.8" data-path="../ch10-system-level-io/10.8-sharing-files.html">
            
                <a href="../ch10-system-level-io/10.8-sharing-files.html">
            
                    
                    10.8 共享文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.9" data-path="../ch10-system-level-io/10.9-io-redirection.html">
            
                <a href="../ch10-system-level-io/10.9-io-redirection.html">
            
                    
                    10.9 I/O 重定向
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.10" data-path="../ch10-system-level-io/10.10-standard-io.html">
            
                <a href="../ch10-system-level-io/10.10-standard-io.html">
            
                    
                    10.10 标准 I/O
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.11" data-path="../ch10-system-level-io/10.11-putting-it-together-which-io-functions-should-i-use.html">
            
                <a href="../ch10-system-level-io/10.11-putting-it-together-which-io-functions-should-i-use.html">
            
                    
                    10.11 综合：我该使用哪些 I/O 函数？
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.12" data-path="../ch10-system-level-io/10.12-summary.html">
            
                <a href="../ch10-system-level-io/10.12-summary.html">
            
                    
                    10.12 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.13" data-path="../ch10-system-level-io/homework.html">
            
                <a href="../ch10-system-level-io/homework.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="6.2" data-path="./">
            
                <a href="./">
            
                    
                    第 11 章：网络编程
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.2.1" data-path="11.1-the-client-server-programming-model.html">
            
                <a href="11.1-the-client-server-programming-model.html">
            
                    
                    11.1 客户端—服务器编程模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2.2" data-path="11.2-networks.html">
            
                <a href="11.2-networks.html">
            
                    
                    11.2 网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2.3" data-path="11.3-the-global-ip-internet.html">
            
                <a href="11.3-the-global-ip-internet.html">
            
                    
                    11.3 全球 IP 因特网
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="6.2.4" data-path="11.4-the-sockets-interface.html">
            
                <a href="11.4-the-sockets-interface.html">
            
                    
                    11.4 套接字接口
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2.5" data-path="11.5-web-servers.html">
            
                <a href="11.5-web-servers.html">
            
                    
                    11.5 Web 服务器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2.6" data-path="11.6-putting-it-together-the-tiny-web-server.html">
            
                <a href="11.6-putting-it-together-the-tiny-web-server.html">
            
                    
                    11.6 综合：TINY Web 服务器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2.7" data-path="11.7-summary.html">
            
                <a href="11.7-summary.html">
            
                    
                    11.7 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2.8" data-path="homework.html">
            
                <a href="homework.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="6.3" data-path="../ch12-concurrent-programming/">
            
                <a href="../ch12-concurrent-programming/">
            
                    
                    第 12 章：并发编程
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.3.1" data-path="../ch12-concurrent-programming/12.1-concurrent-programming-with-processes.html">
            
                <a href="../ch12-concurrent-programming/12.1-concurrent-programming-with-processes.html">
            
                    
                    12.1 基于进程的并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.2" data-path="../ch12-concurrent-programming/12.2-concurrent-programming-with-io-multiplexing.html">
            
                <a href="../ch12-concurrent-programming/12.2-concurrent-programming-with-io-multiplexing.html">
            
                    
                    12.2 基于 I/O 多路复用的并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.3" data-path="../ch12-concurrent-programming/12.3-concurrent-programming-with-threads.html">
            
                <a href="../ch12-concurrent-programming/12.3-concurrent-programming-with-threads.html">
            
                    
                    12.3 基于线程的并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.4" data-path="../ch12-concurrent-programming/12.4-shared-variables-in-threaded-programs.html">
            
                <a href="../ch12-concurrent-programming/12.4-shared-variables-in-threaded-programs.html">
            
                    
                    12.4 多线程程序中的共享变量
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.5" data-path="../ch12-concurrent-programming/12.5-synchronizing-thread-with-semaphores.html">
            
                <a href="../ch12-concurrent-programming/12.5-synchronizing-thread-with-semaphores.html">
            
                    
                    12.5 用信号量同步线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.6" data-path="../ch12-concurrent-programming/12.6-using-threads-for-parallelism.html">
            
                <a href="../ch12-concurrent-programming/12.6-using-threads-for-parallelism.html">
            
                    
                    12.6 使用线程提高并行性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.7" data-path="../ch12-concurrent-programming/12.7-other-concurrency-issues.html">
            
                <a href="../ch12-concurrent-programming/12.7-other-concurrency-issues.html">
            
                    
                    12.7 其他并发问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.8" data-path="../ch12-concurrent-programming/12.8-summary.html">
            
                <a href="../ch12-concurrent-programming/12.8-summary.html">
            
                    
                    12.8 小结
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3.9" data-path="../ch12-concurrent-programming/homework.html">
            
                <a href="../ch12-concurrent-programming/homework.html">
            
                    
                    家庭作业
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../../appendix-error-handling.html">
            
                <a href="../../appendix-error-handling.html">
            
                    
                    附录 A：错误处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="7.2" data-path="../../references.html">
            
                <a href="../../references.html">
            
                    
                    参考文献
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">实验</li>
        
        
    
        <li class="chapter " data-level="8.1" data-path="../../labs/labs-overview/">
            
                <a href="../../labs/labs-overview/">
            
                    
                    实验总览
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" data-path="../../labs/labs-overview/common-problems.html">
            
                <a href="../../labs/labs-overview/common-problems.html">
            
                    
                    常见问题
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="8.2" data-path="../../labs/data-lab/">
            
                <a href="../../labs/data-lab/">
            
                    
                    实验 1：Data Lab
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.2.1" data-path="../../labs/data-lab/readme-instructor.html">
            
                <a href="../../labs/data-lab/readme-instructor.html">
            
                    
                    README（讲师版）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.2.2" data-path="../../labs/data-lab/readme-student.html">
            
                <a href="../../labs/data-lab/readme-student.html">
            
                    
                    README（学生版）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.2.3" data-path="../../labs/data-lab/writeup.html">
            
                <a href="../../labs/data-lab/writeup.html">
            
                    
                    Writeup
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="8.3" data-path="../../labs/bomb-lab/">
            
                <a href="../../labs/bomb-lab/">
            
                    
                    实验 2：Bomb Lab
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.3.1" data-path="../../labs/bomb-lab/readme-jiang-shi-ban.html">
            
                <a href="../../labs/bomb-lab/readme-jiang-shi-ban.html">
            
                    
                    README（讲师版）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.3.2" data-path="../../labs/bomb-lab/writeup.html">
            
                <a href="../../labs/bomb-lab/writeup.html">
            
                    
                    Writeup
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="8.4" data-path="../../labs/attack-lab.html">
            
                <a href="../../labs/attack-lab.html">
            
                    
                    实验 3：Attack Lab
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.5" data-path="../../labs/arch-lab.html">
            
                <a href="../../labs/arch-lab.html">
            
                    
                    实验 4：Architechture Lab
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.6" data-path="../../labs/cache-lab.html">
            
                <a href="../../labs/cache-lab.html">
            
                    
                    实验 5：Cache Lab
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.7" data-path="../../labs/perf-lab.html">
            
                <a href="../../labs/perf-lab.html">
            
                    
                    实验 6：Performance Lab
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.8" data-path="../../labs/shell-lab.html">
            
                <a href="../../labs/shell-lab.html">
            
                    
                    实验 7：Shell Lab
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.9" data-path="../../labs/malloc-lab.html">
            
                <a href="../../labs/malloc-lab.html">
            
                    
                    实验 8：Malloc Lab
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.10" data-path="../../labs/proxy-lab.html">
            
                <a href="../../labs/proxy-lab.html">
            
                    
                    实验 9：Proxy Lab
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >11.4 套接字接口</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="114-套接字接口">11.4 套接字接口</h1>
<p><strong>套接字接口</strong>（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统。图 11-12 给岀了一个典型的客户端—服务器事务的上下文中的套接字接口概述。当讨论各个函数时，你可以使用这张图来作为向导图。</p>
<p><img src="../../.gitbook/assets/11-12%20基于套接字接口的网络应用概述.png" alt="图 11-12 基于套接字接口的网络应用概述"></p>
<p><div class="alert alert-info hints-alert"><div class="hints-icon"><i class="fa fa-info-circle"></i></div><div class="hints-container"><h3 id="旁注---套接字接口的起源">旁注 - 套接字接口的起源</h3>
<p>套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早期提出的。因为这个原因，它也经常被叫做伯克利套接字。伯克利的研究者使得套接字接口适用于任何底层的协议。第一个实现的就是针对 TCP/IP 协议的，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。这在因特网的历史上是一个重大事件。几乎一夜之间，成千上万的人们接触到了 TCP/IP 和它的源代码。它引起了巨大的轰动，并激发了新的网络和网络互联研究的浪潮。</p>
</div></div></p>
<h2 id="1141-套接字地址结构">11.4.1 套接字地址结构</h2>
<p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。从 Linux 程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<p>因特网的套接字地址存放在如图 11-13 所示的类型为 sockaddr_in 的 16 字节结构中。对于因特网应用，sin_family 成员是 AF_INET，sin_port 成员是一个 16 位的端口号，而 sin_addr 成员就是一个 32 位的 IP 地址。IP 地址和端口号总是以网络字节顺序（大端法）存放的。</p>
<pre><code class="lang-c"><span class="hljs-comment">/* IP socket address structure */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> {</span>
    <span class="hljs-keyword">uint16_t</span>       sin_family;   <span class="hljs-comment">/* Protocol family (always AF_INET) */</span>
    <span class="hljs-keyword">uint16_t</span>       sin_port;     <span class="hljs-comment">/* Port number in network byte order */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>     <span class="hljs-comment">/* IP address in network byte order */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>  sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">/* Pad to sizeof(struct sockaddr) */</span>
};

<span class="hljs-comment">/* Generic socket address structure (for connect, bind, and accept) */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> {</span>
    <span class="hljs-keyword">uint16_t</span>  sa_family;    <span class="hljs-comment">/* Protocol family */</span>
    <span class="hljs-keyword">char</span>      sa_data[<span class="hljs-number">14</span>];  <span class="hljs-comment">/* Address data */</span>
};
</code></pre>
<blockquote>
<p>图 11-13 套接字地址结构</p>
</blockquote>
<p><div class="alert alert-info hints-alert"><div class="hints-icon"><i class="fa fa-info-circle"></i></div><div class="hints-container"><h3 id="旁注---in后缀意味着什么？">旁注 - _in后缀意味着什么？</h3>
<p>in 后缀是互联网络（internet）的缩写，而不是输入（input）的缩写。</p>
</div></div></p>
<p>connect、bind 和 accept 函数要求一个指向与协议相关的套接字地址结构的指针。套接字接口的设计者面临的问题是，如何定义这些函数，使之能接受各种类型的套接字地址结构。今天我们可以使用通用的 <strong>void*</strong> 指针，但是那时在 C 中并不存在这种类型的指针。解决办法是定义套接字函数要求一个指向通用 sockaddr 结构（图 11-13）的指针，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用结构。为了简化代码示例，我们跟随 Steven 的指导，定义下面的类型：</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">SA</span>;</span>
</code></pre>
<p>然后无论何时需要将 sockaddr_in 结构强制转换成通用 sockaddr 结构时，我们都使用这个类型。</p>
<h2 id="1142-socket-函数">11.4.2 socket 函数</h2>
<p>客户端和服务器使用 socket 函数来创建一个<strong>套接字描述符</strong>（socket descriptor）。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span>;

<span class="hljs-comment">// 返回：若成功则为非负描述符，若出错则为 -1。</span>
</code></pre>
<p>如果想要使套接字成为连接的一个端点，就用如下硬编码的参数来调用 socket 函数：</p>
<pre><code class="lang-c">clientfd = Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
</code></pre>
<p>其中，AF_INET 表明我们正在使用 32 位 IP 地址，而 SOCK_STREAM 表示这个套接字是连接的一个端点。不过最好的方法是用 getaddrinfo 函数（11.4.7 节）来自动生成这些参数，这样代码就与协议无关了。我们会在 11.4.8 节中向你展示如何配合 socket 函数来使用 getaddrinfo。</p>
<p>socket 返回的 clientfd 描述符仅是部分打开的，还不能用于读写。如何完成打开套接字的工作，取决于我们是客户端还是服务器。下一节描述当我们是客户端时如何完成打开套接字的工作。</p>
<h2 id="1143-connect-函数">11.4.3 connect 函数</h2>
<p>客户端通过调用 connect 函数来建立和服务器的连接。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> clientfd, <span class="hljs-keyword">const</span> struct sockaddr *addr,
            <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;

<span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span>
</code></pre>
<p>connect 函数试图与套接字地址为 addr 的服务器建立一个因特网连接，其中 addrlen 是 <strong>sizeof(sockaddr_in)</strong>。connect 函数会阻塞，一直到连接成功建立或是发生错误。如果成功，clientfd 描述符现在就准备好可以读写了，并且得到的连接是由套接字对</p>
<p><strong>(x:y, addr.sin_addr:addr.sin_port)</strong></p>
<p>刻画的，其中 x 表示客户端的 IP 地址，而 y 表示临时端口，它唯一地确定了客户端主机上的客户端进程。对于 socket，最好的方法是用 getaddrinfo 来为 connect 提供参数（见 11.4.8 节）。</p>
<h2 id="1144-bind-函数">11.4.4 bind 函数</h2>
<p>剩下的套接字函数——bind、listen 和 accept，服务器用它们来和客户端建立连接。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr,
         <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;

<span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span>
</code></pre>
<p>bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来。参数 addrlen 就是 <strong>sizeof(sockaddr_in)</strong>。对于 socket 和 connect，最好的方法是用 getaddrinfo 来为 bind 提供参数（见 11.4.8 节）。</p>
<h2 id="1145-listen-函数">11.4.5 listen 函数</h2>
<p>客户端是发起连接请求的主动实体。服务器是等待来自客户端的连接请求的被动实体。默认情况下，内核会认为 socket 函数创建的描述符对应于<strong>主动套接字</strong>（active socket），它存在于一个连接的客户端。服务器调用 listen 函数告诉内核，描述符是被服务器而不是客户端使用的。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;

<span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span>
</code></pre>
<p>listen 函数将 sockfd 从一个主动套接字转化为一个<strong>监听套接字</strong>（listening socket），该套接字可以接受来自客户端的连接请求。backlog 参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。backlog 参数的确切含义要求对 TCP/IP 协议的理解，这超出了我们讨论的范围。通常我们会把它设置为一个较大的值，比如 1024。</p>
<h2 id="1146-accept-函数">11.4.6 accept 函数</h2>
<p>服务器通过调用 accept 函数来等待来自客户端的连接请求。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> listenfd, struct sockaddr *addr, <span class="hljs-keyword">int</span> *addrlen)</span></span>;

<span class="hljs-comment">// 返回：若成功则为非负连接描述符，若出错则为 -1。</span>
</code></pre>
<p>accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个<strong>已连接描述符</strong>（connected descriptor），这个描述符可被用来利用 Unix I/O 函数与客户端通信。</p>
<p>监听描述符和已连接描述符之间的区别使很多人感到迷惑。监听描述符是作为客户端连接请求的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点。服务器每次接受连接请求时都会创建一次，它只存在于服务器为一个客户端服务的过程中。</p>
<p>图 11-14 描绘了监听描述符和已连接描述符的角色。</p>
<p><img src="../../.gitbook/assets/11-14%20监听描述符和已连接描述符的角色.png" alt="图 11-14 监听描述符和已连接描述符的角色"></p>
<p>在第一步中，服务器调用 accept，等待连接请求到达监听描述符，具体地我们设定为描述符 3。回忆一下，描述符 0 ~ 2 是预留给了标准文件的。</p>
<p>在第二步中，客户端调用 connect 函数，发送一个连接请求到 listenfd。第三步，accept 函数打开了一个新的已连接描述符 connfd（我们假设是描述符 4），在 clientfd 和 connfd 之间建立连接，并且随后返回 connfd 给应用程序。客户端也从 connect 返回，在这一点以后，客户端和服务器就可以分别通过读和写 clientfd 和 connfd 来回传送数据了。</p>
<p><div class="alert alert-info hints-alert"><div class="hints-icon"><i class="fa fa-info-circle"></i></div><div class="hints-container"><h3 id="旁注---为何要有监听描述符和已连接描述符之间的区别？">旁注 - 为何要有监听描述符和已连接描述符之间的区别？</h3>
<p>你可能很想知道为什么套接字接口要区别监听描述符和已连接描述符。乍一看，这像是不必要的复杂化。然而，区分这两者被证明是很有用的，因为它使得我们可以. 建立并发服务器，它能够同时处理许多客户端连接。例如，每次一个连接请求到达监听描述符时，我们可以派生（fork）—个新的进程，它通过已连接描述符与客户端通信。在第 12 章中将介绍更多关于并发服务器的内容。</p>
</div></div></p>
<h2 id="1147-主机和服务的转换">11.4.7 主机和服务的转换</h2>
<p>Linux 提供了一些强大的函数（称为 getaddrinfo 和 getnameinfo）实现二进制套接字地址结构和主机名、主机地址、服务名和端口号的字符串表示之间的相互转化。当和套接字接口一起使用时，这些函数能使我们编写独立于任何特定版本的 IP 协议的网络程序。</p>
<h3 id="1-getaddrinfo-函数">1. getaddrinfo 函数</h3>
<p>getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。它是已弃用的 gethostbyname 和 getservbyname 函数的新的替代品。和以前的那些函数不同，这个函数是可重入的（见 12.7.2 节），适用于任何协议。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service,
                <span class="hljs-keyword">const</span> struct addrinfo *hints,
                struct addrinfo **result)</span></span>;
<span class="hljs-comment">// 返回：如果成功则为 0，如果错误则为非零的错误代码。</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(struct addrinfo *result)</span></span>;
<span class="hljs-comment">// 返回：无。</span>

<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> errcode)</span></span>;
<span class="hljs-comment">// 返回：错误消息。</span>
</code></pre>
<p>给定 host 和 service（套接字地址的两个组成部分），getaddrinfo 返回 result，result 一个指向 addrinfo 结构的链表，其中每个结构指向一个对应于 host 和 service 的套接字地址结构（图 11-15）。</p>
<p><img src="../../.gitbook/assets/1115-getaddrinfo-fan-hui-de-shu-ju-jie-gou-.png" alt="图 11-15 getaddrinfo 返回的数据结构"></p>
<p>在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接。类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址。为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表。如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串。</p>
<p>getaddrinfo 的 host 参数可以是域名，也可以是数字地址（如点分十进制 IP 地址）。service 参数可以是服务名（如 http），也可以是十进制端口号。如果不想把主机名转换成地址，可以把 host 设置为 NULL。对 service 来说也是一样。但是必须指定两者中至少一个。</p>
<p>可选的参数 hints 是一个 addrinfo 结构（见图 11-16），它提供对 getaddrinfo 返回的套接字地址列表的更好的控制。</p>
<pre><code class="lang-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> {</span>
    <span class="hljs-keyword">int</span>             ai_flags;      <span class="hljs-comment">/* Hints argument flags */</span>
    <span class="hljs-keyword">int</span>             ai_family;     <span class="hljs-comment">/* First arg to socket function */</span>
    <span class="hljs-keyword">int</span>             ai_socktype;   <span class="hljs-comment">/* Second arg to socket function */</span>
    <span class="hljs-keyword">int</span>             ai_protocol;   <span class="hljs-comment">/* Third arg to socket function */</span>
    <span class="hljs-keyword">char</span>            *ai_canonname; <span class="hljs-comment">/* Canonical hostname */</span>
    <span class="hljs-keyword">size_t</span>          ai_addrlen;    <span class="hljs-comment">/* Size of ai_addr struct */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">ai_addr</span>;</span>      <span class="hljs-comment">/* Ptr to socket address structure */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">ai_next</span>;</span>      <span class="hljs-comment">/* Ptr to next item in linked list */</span>
};
</code></pre>
<blockquote>
<p>图 11-16 getaddrinfo 使用的 addrinfo 结构</p>
</blockquote>
<p>如果要传递 hints 参数，只能设置下列字段：ai_family、ai_socktype、ai_protocol 和 ai_flags 字段。其他字段必须设置为 0（或 NULL）。实际中，我们用 memset 将整个结而清零，然后有选择地设置一些字段：</p>
<ul>
<li>getaddrinfo 默认可以返回 IPv4 和 IPv6 套接字地址。ai_family 设置为 AF_INET 会将列表限制为 IPv4 地址；设置为 AF_INET6 则限制为 IPv6 地址。</li>
<li>对于 host 关联的每个地址，getaddrinfo 函数默认最多返回三个 addrinfo 结构，每个的 ai_socktype 字段不同：一个是连接，一个是数据报（本书未讲述），一个是原始套接字（本书未讲述）。ai_socktype 设置为 SOCK_STREAM 将列表限制为对每个地址最多一个 addrinfo 结构，该结构的套接字地址可以作为连接的一个端点。这是所有示例程序所期望的行为。</li>
<li>ai_flags 字段是一个位掩码，可以进一步修改默认行为。可以把各种值用 OR 组合起来得到该掩码。下面是一些我们认为有用的值：<ul>
<li><strong>AI_ADDRCONFIG。</strong>如果在使用连接，就推荐使用这个标志【34】。它要求只有当本地主机被配置为 IPv4 时，getaddrinfo 返回 IPv4 地址。对 IPv6 也是类似。</li>
<li><strong>AI_CANONNAME。</strong>ai_canonname 字段默认为 NULL。如果设置了该标志，就是告诉 getaddrinfo 将列表中第一个 addrinfo 结构的 ai_canonname 字段指向 host 的权威（官方）名字（见图 11-15）。</li>
<li><strong>AI_NUMERICSERV。</strong>参数 service 默认可以是服务名或端口号。这个标志强制参数 service 为端口号。</li>
<li><strong>AI_PASSIVE。</strong>getaddrinfo 默认返回套接字地址，客户端可以在调用 connect 时用作主动套接字。这个标志告诉该函数，返回的套接字地址可能被服务器用作监听套接字。在这种情况中，参数 host 应该为 NULL。得到的套接字地址结构中的地址字段会是通配符地址（wildcard address），告诉内核这个服务器会接受发送到该主机所有 IP 地址的请求。这是所有示例服务器所期望的行为。</li>
</ul>
</li>
</ul>
<p>当 getaddrinfo 创建输出列表中的 addrinfo 结构时，会填写每个字段，除了 ai_flags。ai_addr 字段指向一个套接字地址结构，ai_addrlen 字段给出这个套接字地址结构的大小，而 ai_next 字段指向列表中下一个 addrinfo 结构。其他字段描述这个套接字地址的各种属性。</p>
<p>getaddrinfo 一个很好的方面是 addrinfo 结构中的字段是不透明的，即它们可以直接传递给套接字接口中的函数，应用程序代码无需再做任何处理。例如，ai_family、ai_socktype 和 ai_protocol 可以直接传递给 socket。类似地，ai_addr 和 ai_addrlen 可以直接传递给 connect 和 bind。这个强大的属性使得我们编写的客户端和服务器能够独立于某个特殊版本的 IP 协议。</p>
<h3 id="2-getnameinfo-函数">2. getnameinfo 函数</h3>
<p>getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串。它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品，和以前的那些函数不同，它是可重入和与协议无关的。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnameinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sa, <span class="hljs-keyword">socklen_t</span> salen,
                <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">size_t</span> hostlen,
                <span class="hljs-keyword">char</span> *service, <span class="hljs-keyword">size_t</span> servlen, <span class="hljs-keyword">int</span> flags)</span></span>;

<span class="hljs-comment">// 返回：如果成功则为 0，如果错误则为非零的错误代码。</span>
</code></pre>
<p>参数 sa 指向大小为 salen 字节的套接字地址结构，host 指向大小为 hostlen 字节的缓冲区，service 指向大小为 servlen 字节的缓冲区。getnameinfo 函数将套接字地址结构 sa 转换成对应的主机和服务名字符串，并将它们复制到 host 和 serveice 缓冲区。如果 getnameinfo 返回非零的错误代码，应用程序可以调用 gai_strerror 把它转化成字符串。</p>
<p>如果不想要主机名，可以把 host 设置为 NULL，hostlen 设置为 0。对服务字段来说也是一样。不过，两者必须设置其中之一。</p>
<p>参数 flags 是一个位掩码，能够修改默认的行为。可以把各种值用 OR 组合起来得到该掩码。下面是两个有用的值：</p>
<ul>
<li><strong>NI_NUMERICHOST。</strong>getnameinfo 默认试图返回 host 中的域名。设置该标志会使该函数返回一个数字地址字符串。</li>
<li><strong>NI_NUMERICSERV。</strong>getnameinfo 默认会检查 <strong>/etc/services</strong>，如果可能，会返回服务名而不是端口号。设置该标志会使该函数跳过査找，简单地返回端口号。</li>
</ul>
<p>图 11-17 给出了一个简单的程序，称为 HOSTINFO，它使用 getaddrinfo 和 getnameinfo 展示出域名到和它相关联的 IP 地址之间的映射。该程序类似于 11.3.2 节中的 NSLOOKUP 程序。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">listp</span>, <span class="hljs-title">hints</span>;</span>
    <span class="hljs-keyword">char</span> buf[MAXLINE];
    <span class="hljs-keyword">int</span> rc, flags;

    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;domain name&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">/* Get a list of addrinfo records */</span>
    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct addrinfo));
    hints.ai_family = AF_INET;       <span class="hljs-comment">/* IPv4 only */</span>
    hints.ai_socktype = SOCK_STREAM; <span class="hljs-comment">/* Connections only */</span>
    <span class="hljs-keyword">if</span> ((rc = getaddrinfo(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(rc));
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">/* Walk the list and display each IP address */</span>
    flags = NI_NUMERICHOST; <span class="hljs-comment">/* Display address string instead of domain name */</span>
    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) {
        Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, flags);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);
    }

    <span class="hljs-comment">/* Clean up */</span>
    Freeaddrinfo(listp);

    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<blockquote>
<p>图 11-17 HOSTINFO 展示出域名到和它相关联的 IP 地址之间的映射</p>
</blockquote>
<p>首先，初始化 hints 结构，使 getaddrinfo 返回我们想要的地址。在这里，我们想查找 32 位的 IP 地址（第 16 行），用作连接的端点（第 17 行）。因为只想 getaddrinfo 转换域名，所以用 service 参数为 NULL 来调用它。</p>
<p>调用 getaddrinfo 之后，会遍历 addrinfo 结构，用 getnameinfo 将每个套接字地址转换成点分十进制地址字符串。遍历完列表之后，我们调用 freeaddrinf。小心地释放这个列表（虽然对于这个简单的程序来说，并不是严格需要这样做的）。</p>
<p>运行 HOSTINFO 时，我们看到 twitter.com 映射到了四个 IP 地址，和 11.3.2 节用 NSLOOKUP 的结果一样。</p>
<pre><code class="lang-c">linux&gt; ./hostinfo twitter.com
<span class="hljs-number">199.16</span><span class="hljs-number">.156</span><span class="hljs-number">.102</span>
<span class="hljs-number">199.16</span><span class="hljs-number">.156</span><span class="hljs-number">.230</span>
<span class="hljs-number">199.16</span><span class="hljs-number">.156</span><span class="hljs-number">.6</span>
<span class="hljs-number">199.16</span><span class="hljs-number">.156</span><span class="hljs-number">.70</span>
</code></pre>
<h4 id="练习题-114">练习题 11.4</h4>
<p>函数 getaddrinfo 和 getnameinfo 分别包含了 inet_pton 和 inet_ntop 的功能，提供了更高级别的、独立于任何特殊地址格式的抽象。想看看这到底有多方便，编写 HOSTINFO（图 11-17）的一个版本，用 inet_pton 而不是 getnameinfo 将毎个套接字地址转换成点分十进制地址字符串。</p>
<p>下面是解决方案。注意，使用 inet_ntop 要困难多少，它要求很麻烦的强制类型转换和深层嵌套结构引用。getnameinfo 函数要简单许多，因为它为我们完成了这些工作。</p>
<p>
```c
#include &quot;csapp.h&quot;

int main(int argc, char **argv)
{
    struct addrinfo *p, *listp, hints;
    struct sockaddr_in *sockp;
    char buf[MAXLINE];
    int rc;

    if (argc != 2) {
        fprintf(stderr, &quot;usage: %s <domain name>\n&quot;, argv[0]);
        exit(0);
    }

    /* Get a list of addrinfo records */
    memset(&amp;hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET;       /* IPv4 only */
    hints.ai_socktype = SOCK_STREAM; /* Connections only */
    if ((rc = getaddrinfo(argv[1], NULL, &amp;hints, &amp;listp)) != 0) {
        fprintf(stderr, &quot;getaddrinfo error: %s\n&quot;, gai_strerror(rc));
        exit(1);
    }

    /* Walk the list and display each associated IP address */
    for (p = listp; p; p = p-&gt;ai_next) {
        sockp = (struct sockaddr_in *)p-&gt;ai_addr;
        Inet_ntop(AF_INET, &amp;(sockp-&gt;sin_addr), buf, MAXLINE);
        printf(&quot;%s\n&quot;, buf);
    }

    /* Clean up */
    Freeaddrinfo(listp);

    exit(0);
}
```
</domain></p>
<h2 id="1148-套接字接口的辅助函数">11.4.8 套接字接口的辅助函数</h2>
<p>初学时，getnameinfo 函数和套接字接口看上去有些可怕。用高级的辅助函数包装一下会方便很多，称为 open_clientfd 和 open_listenfd，客户端和服务器互相通信时可以使用这些函数。</p>
<h3 id="1-openclientfd-函数">1. open_clientfd 函数</h3>
<p>客户端调用 open_clientfd 建立与服务器的连接。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_clientfd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *hostname, <span class="hljs-keyword">char</span> *port)</span></span>;

<span class="hljs-comment">// 返回：若成功则为描述符，若出错则为 -1。</span>
</code></pre>
<p>open_clientfd 函数建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port 上监听连接请求。它返回一个打开的套接字描述符，该描述符准备好了，可以用 Unix I/O 函数做输入和输出。图 11-18 给出了 open_clientfd 的代码。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_clientfd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *hostname, <span class="hljs-keyword">char</span> *port)</span> </span>{
    <span class="hljs-keyword">int</span> clientfd;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>, *<span class="hljs-title">listp</span>, *<span class="hljs-title">p</span>;</span>

    <span class="hljs-comment">/* Get a list of potential server addresses */</span>
    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;  <span class="hljs-comment">/* Open a connection */</span>
    hints.ai_flags = AI_NUMERICSERV;  <span class="hljs-comment">/* ... using a numeric port arg. */</span>
    hints.ai_flags |= AI_ADDRCONFIG;  <span class="hljs-comment">/* Recommended for connections */</span>
    Getaddrinfo(hostname, port, &amp;hints, &amp;listp);

    <span class="hljs-comment">/* Walk the list for one that we can successfully connect to */</span>
    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) {
        <span class="hljs-comment">/* Create a socket descriptor */</span>
        <span class="hljs-keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Socket failed, try the next */</span>

        <span class="hljs-comment">/* Connect to the server */</span>
        <span class="hljs-keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="hljs-number">-1</span>)
            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* Success */</span>
        Close(clientfd); <span class="hljs-comment">/* Connect failed, try another */</span>
    }

    <span class="hljs-comment">/* Clean up */</span>
    Freeaddrinfo(listp);
    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">/* All connects failed */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">else</span>    <span class="hljs-comment">/* The last connect succeeded */</span>
        <span class="hljs-keyword">return</span> clientfd;
}
</code></pre>
<blockquote>
<p>图 11-18 open_clientfd：和服务器建立连接的辅助函数。它是可重入和与协议无关的</p>
</blockquote>
<p>我们调用 getaddrinfo，它返回 addrinf。结构的列表，每个结构指向一个套接字地址结构，可用于建立与服务器的连接，该服务器运行在 hostname 上并监听 port 端口。然后遍历该列表，依次尝试列表中的每个条目，直到调用 socket 和 connect 成功。如果 connect 失败，在尝试下一个条目之前，要小心地关闭套接字描述符。如果 connect 成功，我们会释放列表内存，并把套接字描述符返回给客户端，客户端可以立即开始用 Unix I/O 与服务器通信了。</p>
<p>注意，所有的代码都与任何版本的 IP 无关。socket 和 connect 的参数都是用 getaddrinfo 自动产生的，这使得我们的代码干净可移植。</p>
<h3 id="2-openlistenfd-函数">2. open_listenfd 函数</h3>
<p>调用 open_listenfd 函数，服务器创建一个监听描述符，准备好接收连接请求。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_listenfd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *port)</span></span>;

<span class="hljs-comment">// 返回：若成功则为描述符，若出错则为 -1。</span>
</code></pre>
<p>open_listenfd 函数打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求。图 11-19 展示了 open_listenfd 的代码。</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_listenfd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *port)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>, *<span class="hljs-title">listp</span>, *<span class="hljs-title">p</span>;</span>
    <span class="hljs-keyword">int</span> listenfd, optval = <span class="hljs-number">1</span>;

    <span class="hljs-comment">/* Get a list of potential server addresses */</span>
    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;             <span class="hljs-comment">/* Accept connections */</span>
    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="hljs-comment">/* ... on any IP address */</span>
    hints.ai_flags |= AI_NUMERICSERV;            <span class="hljs-comment">/* ... using port number */</span>
    Getaddrinfo(<span class="hljs-literal">NULL</span>, port, &amp;hints, &amp;listp);

    <span class="hljs-comment">/* Walk the list for one that we can bind to */</span>
    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) {
        <span class="hljs-comment">/* Create a socket descriptor */</span>
        <span class="hljs-keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Socket failed, try the next */</span>

        <span class="hljs-comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span>
        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)&amp;optval , <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));

        <span class="hljs-comment">/* Bind the descriptor to the address */</span>
        <span class="hljs-keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* Success */</span>
        Close(listenfd); <span class="hljs-comment">/* Bind failed, try the next */</span>
    }

    <span class="hljs-comment">/* Clean up */</span>
    Freeaddrinfo(listp);
    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">/* No address worked */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-comment">/* Make it a listening socket ready to accept connection requests */</span>
    <span class="hljs-keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="hljs-number">0</span>) {
        Close(listenfd);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">return</span> listenfd;
}
</code></pre>
<blockquote>
<p>图 11-19 open_listenfd：打开并返回监听描述符的辅助函数。它是可重入和与协议无关的</p>
</blockquote>
<p>open_listenfd 的风格类似于 open_clientfd。调用 getaddrinfo，然后遍历结果列表，直到调用 socket 和 bind 成功。注意，在第 20 行，我们使用 setsockopt 函数（本书中没有讲述）来配置服务器，使得服务器能够被终止、重启和立即开始接收连接请求。一个重启的服务器默认将在大约 30 秒内拒绝客户端的连接请求，这严重地阻碍了调试。</p>
<p>因为我们调用 getaddrinfo 时，使用了 AI_PASSIVE 标志并将 host 参数设置为 NULL，每个套接字地址结构中的地址字段会被设置为通配符地址，这告诉内核这个服务器会接收发送到本主机所有 IP 地址的请求。</p>
<p>最后，我们调用 listen 函数，将 listenfd 转换为一个监听描述符，并返回给调用者。如果 listen 失败，我们要小心地避免内存泄漏，在返回前关闭描述符。</p>
<h2 id="1149-echo-客户端和服务器的示例">11.4.9 echo 客户端和服务器的示例</h2>
<p>学习套接字接口的最好方法是研究示例代码。图 11-20 展示了一个 echo 客户端的代码。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>
</span>{
    <span class="hljs-keyword">int</span> clientfd;
    <span class="hljs-keyword">char</span> *host, *port, buf[MAXLINE];
    <span class="hljs-keyword">rio_t</span> rio;

    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;host&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }
    host = argv[<span class="hljs-number">1</span>];
    port = argv[<span class="hljs-number">2</span>];

    clientfd = Open_clientfd(host, port);
    Rio_readinitb(&amp;rio, clientfd);

    <span class="hljs-keyword">while</span> (Fgets(buf, MAXLINE, <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) {
        Rio_writen(clientfd, buf, <span class="hljs-built_in">strlen</span>(buf));
        Rio_readlineb(&amp;rio, buf, MAXLINE);
        Fputs(buf, <span class="hljs-built_in">stdout</span>);
    }
    Close(clientfd);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<blockquote>
<p>图 11-20 echo 客户端的主程序</p>
</blockquote>
<p>在和服务器建立连接之后，客户端进入一个循环，反复从标准输入读取文本行，发送文本行给服务器，从服务器读取回送的行，并输出结果到标准输出。当 fgets 在标准输入上遇到 EOF 时，或者因为用户在键盘上键入 Ctrl+D，或者因为在一个重定向的输入文件中用尽了所有的文本行时，循环就终止。</p>
<p>循环终止之后，客户端关闭描述符。这会导致发送一个 EOF 通知到服务器，当服务器从它的 reo_readlineb 函数收到一个为零的返回码时，就会检测到这个结果。在关闭它的描述符后，客户端就终止了。既然客户端内核在一个进程终止时会自动关闭所有打开的描述符，第 24 行的 close 就没有必要了。不过，显式地关闭已经打开的任何描述符是一个良好的编程习惯。</p>
<p>图 11-21 展示了 echo 服务器的主程序。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connfd)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span>
</span>{
    <span class="hljs-keyword">int</span> listenfd, connfd;
    <span class="hljs-keyword">socklen_t</span> clientlen;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span> <span class="hljs-comment">/* Enough space for any address */</span>
    <span class="hljs-keyword">char</span> client_hostname[MAXLINE], client_port[MAXLINE];

    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        clientlen = <span class="hljs-keyword">sizeof</span>(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, MAXLINE,
                    client_port, MAXLINE, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);
        echo(connfd);
        Close(connfd);
    }
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<blockquote>
<p>图 11-21 迭代 echo 服务器的主程序</p>
</blockquote>
<p>在打开监听描述符后，它进入一个无限循环。每次循环都等待一个来自客户端的连接请求，输出已连接客户端的域名和 IP 地址，并调用 echo 函数为这些客户端服务。在 echo 程序返回后，主程序关闭已连接描述符。一旦客户端和服务器关闭了它们各自的描述符，连接也就终止了。</p>
<p>第 9 行的 clientaddr 变量是一个套接字地址结构，被传递给 accept。在 accept 返回之前，会在 clientaddr 中填上连接另一端客户端的套接字地址。注意，我们将 clientaddr 声明为 <strong>struct sockaddr_storage</strong> 类型，而不是 <strong>struct sockaddr_in</strong> 类型。根据定义，sockaddr_storage 结构足够大能够装下任何类型的套接字地址，以保持代码的协议无关性。</p>
<p>注意，简单的 echo 服务器一次只能处理一个客户端。这种类型的服务器一次一个地在客户端间迭代，称为<strong>迭代服务器</strong>（iterative server）。在第 12 章中，我们将学习如何建立更加复杂的<strong>并发服务器</strong>（concurrent server），它能够同时处理多个客户端。</p>
<p>最后，图 11-22 展示了 echo 程序的代码，该程序反复读写文本行，直到 rio_readlineb 函数在第 10 行遇到 EOF。</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connfd)</span>
</span>{
    <span class="hljs-keyword">size_t</span> n;
    <span class="hljs-keyword">char</span> buf[MAXLINE];
    <span class="hljs-keyword">rio_t</span> rio;

    Rio_readinitb(&amp;rio, connfd);
    <span class="hljs-keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server received %d bytes\n&quot;</span>, (<span class="hljs-keyword">int</span>)n);
        Rio_writen(connfd, buf, n);
    }
}
</code></pre>
<blockquote>
<p>图 11-22 读和回送文本行的 echo 函数</p>
</blockquote>
<p><div class="alert alert-info hints-alert"><div class="hints-icon"><i class="fa fa-info-circle"></i></div><div class="hints-container"><h3 id="旁注---在连接中-eof-意味什么？">旁注 - 在连接中 EOF 意味什么？</h3>
<p>EOF 的概念常常使人们感到迷惑，尤其是在因特网连接的上下文中。首先，我们需要理解其实并没有像 EOF 字符这样的一个东西。进一步来说，EOF 是由内核检测到的一种条件。应用程序在它接收到一个由 read 函数返回的零返回码时，它就会发现出 EOF 条件。对于磁盘文件，当前文件位置超出文件长度时，会发生 EOF。对于因特网连接，当一个进程关闭连接它的那一端时，会发生 EOF。连接另一端的进程在试图读取流中最后一个字节之后的字节时，会检测到 EOF。</p>
</div></div></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="11.3-the-global-ip-internet.html" class="navigation navigation-prev " aria-label="Previous page: 11.3 全球 IP 因特网">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="11.5-web-servers.html" class="navigation navigation-next " aria-label="Next page: 11.5 Web 服务器">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"11.4 套接字接口","level":"6.2.4","depth":2,"next":{"title":"11.5 Web 服务器","level":"6.2.5","depth":2,"path":"part3/ch11-network-programming/11.5-web-servers.md","ref":"part3/ch11-network-programming/11.5-web-servers.md","articles":[]},"previous":{"title":"11.3 全球 IP 因特网","level":"6.2.3","depth":2,"path":"part3/ch11-network-programming/11.3-the-global-ip-internet.md","ref":"part3/ch11-network-programming/11.3-the-global-ip-internet.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["hints","page-ref","mathjax-pro"],"pluginsConfig":{"hints":{"info":"fa fa-info-circle","tip":"fa fa-mortar-board","danger":"fa fa-exclamation-circle","working":"fa fa-wrench"},"page-ref":{},"mathjax-pro":{"forceSVG":false,"version":"2.7.7"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"part3/ch11-network-programming/11.4-the-sockets-interface.md","mtime":"2022-04-29T14:04:53.398Z","type":"markdown"},"gitbook":{"version":"3.7.1","time":"2022-04-30T05:14:56.515Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-mathjax-pro/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

